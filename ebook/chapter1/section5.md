# 第一章第5讲 其他情况的算法分析
- 最好复杂度
- 最坏复杂度
- 平均复杂度
## 递归算法时空复杂度分析
```
递归算法中执行算法时会多次调用自己，所以时空分析要考虑多层调用的情况。例如

int fun(int i)

{

    if (i==1)

         return 1;

    else

        return i*fun(i-1);

}

在分析调用语句fun(n)的执行时间时，其中没有循环语句，但不能简单地认为是O(1)，分析过程是：

设fun(n)的时间为T(n)，从递归算法看出：

T(1)=1

T(n)=T(n-1)+1    当n>1

所以T(n)=1+T(n-1)=1+1+T(n-2)=...=1+1+1+...+T(1)=n=O(n)。



同样，在分析调用语句fun(n)的空间时，其中定义变量的个数为常量，但不能简单地认为是O(1)，分析过程是：

设fun(n)的空间为S(n)，从递归算法看出：

S(1)=1

S(n)=S(n-1)+1    当n>1

所以S(n)=1+S(n-1)=1+1+S(n-2)=...=1+1+1+...+S(1)=n=O(n)。

因此，调用语句fun(n)的时间复杂度和空间复杂度都是O(n)。
```

## [下一章](../chapter2/section1.md)